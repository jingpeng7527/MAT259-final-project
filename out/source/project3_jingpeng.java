/* autogenerated by Processing revision 1293 on 2024-03-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;
import controlP5.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class project3_jingpeng extends PApplet {

/*************************************************************************************
Mat 259 Project 3 3D Visualization: "movie ratings since 2020 based on IMDb Non-Commercial dataset"               
Tested in Processing 4                                  
                                                     
Author: Jing Peng                       
Supervisor: George Legrady                           

Purpose: Show how to present volume data in a basic 3D environment     

Usage: 1. A mouse left-drag will rotate the camera around the subject.
          2. A right drag will zoom in and out. 
          3. A middle-drag (command-left-drag on mac) will pan. 
          4. A double-click restores the camera to its original position. 
          5. The shift key constrains rotation and panning to one axis or the other.
*************************************************************************************/





PeasyCam cam;
ControlP5 cp5;

PFont font;


int startYear = 2020;
int endYear = 2023;

float radiusMultiplier = 100; // Multiplier for percentage-based radius
float minRadius = 100; // Minimum radius for points
float maxRadius = 200; // Maximum radius for points
float Radius = 200;
float radius = 300;
PVector[] points;
int[] categoryColors = {0xFFB7E1CD, 0xFFD7B5E8, 0xFFF4F1BB, 0xFFF9D0C4, 0xFFA6C8ED};
int[] kind;


Table table;
int numRows, numColumns;

Map<Integer, ArrayList<Movie>> map = new HashMap<Integer,ArrayList<Movie>>();
List<List<PVector>> listAll = new ArrayList<>();

public void setup() {
  /* size commented out by preprocessor */;
  font = createFont("Arial", 100);
  cam = new PeasyCam(this, 400);
  // cam.setMinimumDistance(50);
  // cam.setMaximumDistance(800);
  cp5 = new ControlP5(this);

  loadData();
}

public void draw() {

  background(56, 48, 60);
  gui();

  noFill();
  stroke(0);


  for(int year: map.keySet()){
    
    pushMatrix();
    // translate(x, y, 0);

    drawPoints(year);

    // drawCircleAndText();
    // drawLines(k);
    // drawVertex(k);

    popMatrix();
    //drawLabels();

    
  }
  

  //if((mouseX<180) & (mouseY<180)) {
  //  cam.setActive(false);
  //} else {
  //  cam.setActive(true);
  //}

}

public void gui() {
   hint(DISABLE_DEPTH_TEST);
   cam.beginHUD();
   cp5.draw();
   cam.endHUD();
   hint(ENABLE_DEPTH_TEST);
}
// so that in the larger timeline, we can zoom in even further to a mini timeline which will contain all the books (the in date timeline)
class Movie{
    String title;
    String genres;
    int year;
    int rating;
    int votes;

    Movie(int year, int rating, int votes, String title, String genres){
        this.rating = rating;
        this.votes = votes;
        this.genres = genres;
        this.year = year;
        this.title = title;
    }

    // Setter for title
    public void setTitle(String title) {
        this.title = title;
    }

    // Getter for title
    public String getTitle() {
        return title;
    }

    // Setter for genres
    public void setGenres(String genres) {
        this.genres = genres;
    }

    // Getter for genres
    public String getGenres() {
        return genres;
    }

    // Setter for year
    public void setYear(int year) {
        this.year = year;
    }

    // Getter for year
    public int getYear() {
        return year;
    }

    // Setter for rating
    public void setRating(int rating) {
        this.rating = rating;
    }

    // Getter for rating
    public int getRating() {
        return rating;
    }

    // Setter for votes
    public void setVotes(int votes) {
        this.votes = votes;
    }

    // Getter for votes
    public int getVotes() {
        return votes;
    }
}
// void drawLines(int category){
//     PVector p1;
//     PVector p2;
//     beginShape(); 
//     stroke(categoryColors[category]);
//     //stroke(#FFFFFF);
//     noFill();
//     strokeWeight(1);
//     //tint(255, 126); 
//     for (int i = 0; i < 17; i++) {
//         for (int j = 0; j < 11; j++) {
//             // stroke(#FFFFFF);
//             // strokeWeight(1);
//             p1 = points[(i*12+j)*5+category];
//             curveVertex(p1.x, p1.y, p1.z);
//         }
//     }
//     endShape();

//     beginShape(); 
//      stroke(categoryColors[category]);
//     //stroke(#FFFFFF);
//     noFill();
//     strokeWeight(1);
//     //tint(255, 126); 
     
//     for (int j = 0; j < 11; j++) {
//         for (int i = 0; i < 17; i++) {
//             p1 = points[(i*12+j)*5+category];
//             curveVertex(p1.x, p1.y, p1.z);
//         }
//      }
//      endShape();
// }

// void drawVertex(int category){
//     PVector p;
//     //int start = 0;
//     for (int i = 0; i < 17; ++i) {
//        for(int j = 0; j< 11; j++){
//            //for (int category = 0; category < 5; category++) {
//                beginShape();
//                fill(#FFFFFF, 50);
//                p = points[(i*12+j)*5+category];
//                vertex(p.x, p.y, p.z);
//                p = points[(i*12+(j+1))*5+category];
//                vertex(p.x, p.y, p.z);
//                p = points[((i+1)*12+(j+1))*5+category];
//                vertex(p.x, p.y, p.z);
//                endShape();

//                beginShape();
//                fill(#FFFFFF, 50);
//                p = points[(i*12+j)*5+category];
//                vertex(p.x, p.y, p.z);
//                p = points[((i+1)*12+j)*5+category];
//                vertex(p.x, p.y, p.z);
//                p = points[((i+1)*12+(j+1))*5+category];
//                vertex(p.x, p.y, p.z);
//                endShape();
//                // Category c = categories.get((i*12+j)*5+category);
//                // System.out.println("i: "+c.year+c.month+c.category+" j: "+j+" category: "+category);

//        }
//     }

//     // 2023
//     //for(int m = 0; m < 11; m++){
//     //      int i = (17 * 12 + m) * 5 + category;
//     //      beginShape();
//     //      fill(#FFFFFF, 50);
//     //      p = points[i];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[i+5];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[m*5+5];
//     //       vertex(p.x, p.y, p.z);
//     //       endShape();

//     //       beginShape();
//     //       fill(#FFFFFF, 50);
//     //       p = points[i];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[m*5+5];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[m*5+10];
//     //       vertex(p.x, p.y, p.z);
//     //       endShape();

//         //    Category c = categories.get(i);
//         //    System.out.println("i: "+c.year+c.month+c.category+" j: "+" category: "+category);
//     //}
     
//      // 12
//     //for(int m = 0; m < 17; m++){
//     //  int i = (m * 12 + 11) * 5 + category;
//     //      beginShape();
//     //      fill(#FFFFFF, 50);
//     //       p = points[i];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[i-55];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[i+5];
//     //       vertex(p.x, p.y, p.z);
//     //       endShape();

//     //       beginShape();
//     //       fill(#FFFFFF, 50);
//     //       p = points[i];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[i+60];
//     //       vertex(p.x, p.y, p.z);
//     //       p = points[i+5];
//     //       vertex(p.x, p.y, p.z);
//     //       endShape();

//     //    Category c = categories.get(i);
//     //    System.out.println("kkk"+"i: "+c.year+c.month+c.category+" j: "+" category: "+category);
//     //}
// }

//  void drawCircleAndText() {
//     pushMatrix();
//     //translate(0, 0, -50);
//     //stroke(180);
//     // strokeWeight(1);
//     noFill();
//     //rotateY(PI/2);
//     stroke(180);
//     strokeWeight(1);
//     ellipse(0, 0, maxRadius, maxRadius);
//     popMatrix();


//     for (int i = 0; i < 12; i++) {
//       //noFill();
//       pushMatrix();
//       float theta = (i+1)*PI*2/12;
//       translate(Radius*cos(theta+PI/2), Radius*sin(theta+PI/2));
//       rotate(theta+PI/2+PI);
//       textAlign(LEFT, CENTER);
//       fill(180);
//       textSize(15);
//       text(i+1, 1, 0);
//       popMatrix();
//     }
//     //if (showTitle) {
//     //  textAlign(RIGHT, CENTER);
//     //  fill(180);
//     //  textSize(20);
//     //  text(movieTitle, 190, 0);
//     //  //text(movieTitle, 190, 80);
//     //}

    
//     // Draw the second circle at a 90-degree angle from the first circle
    
//     rotateY(PI/2);
//     pushMatrix();
//     //translate(50, 0, 0);
//     noFill();
//     stroke(180);
//     strokeWeight(1);
//     //stroke(180);
//     // strokeWeight(1);
//     //translate(0, 0, -50);
//     ellipse(0, 0, maxRadius, maxRadius);
//     popMatrix();
    
//     for (int i = 0; i < 18; i++) {
//         pushMatrix();
//         float theta = (i)*TWO_PI/18;
//         translate(Radius*cos(theta+PI/2), Radius*sin(theta+PI/2));
//         rotate(theta+PI);
//         textAlign(RIGHT, CENTER);
//         fill(180);
//         textSize(15);
//         text(i+2006+" ", 0, 0);
//         popMatrix();
//     }
// }

public void drawPoints(int year){
    
    // List<PVector> cur = listAll.get(year-2020);
    // List<Movie> curMovieList = map.get(year);

    // for(int i =0; i<cur.size();i++){
    //     PVector p1 = cur.get(i);
    //     Movie curMovie = curMovieList.get(i);
        
    //     float transparence = map(curMovie.votes, 5000, 590000, 100, 200);
    //     float pointSize = map(curMovie.votes, 5000, 590000, 4, 20);
    //     float titleSize = map(curMovie.votes, 5000, 590000, 2, 9);

    //     pushMatrix();
    //     textSize(titleSize);      
    //     textAlign(CENTER, TOP);      
    //     text(curMovie.title, p1.x, p1.y, p1.z);

    //     stroke(#FFFFFF, transparence);
    //     strokeWeight(pointSize);
    //     point(p1.x, p1.y, p1.z);
    //     popMatrix();
    // }

        
    List<Movie> curMovieList = map.get(year);
    // translate(0,-30 ,0); 

    for(int i =0; i<curMovieList.size();i++){
        // PVector p1 = cur.get(i);
        Movie curMovie = curMovieList.get(i);
        
        float transparence = map(curMovie.votes, 5000, 590000, 100, 200);
        float pointSize = map(curMovie.votes, 5000, 590000, 4, 20);
        float titleSize = map(curMovie.votes, 5000, 590000, 2, 9);

        // float transparence = map((590000-curMovie.votes), 0, 585000, 100, 200);
        // float pointSize = map((590000-curMovie.votes), 0, 585000, 4, 20);
        // float titleSize = map((590000-curMovie.votes), 0, 585000, 2, 9);

        // float x = map((10-curMovie.rating), 0, 10, -minRadius, minRadius);
        // float y = map((590000-curMovie.votes), 0, 585000, -minRadius, minRadius);

        float x = map(curMovie.rating, 0, 10, -minRadius, minRadius);
        float y = map(curMovie.votes, 5000, 590000, -minRadius, minRadius);
        float z = map(curMovie.year, 2020, 2024, -minRadius, minRadius);

        pushMatrix();
        stroke(0xFFFFFFFF, transparence);
        strokeWeight(pointSize);
        point(x, y, z);
        popMatrix();
        
        if (curMovie.rating < 7) {
            System.out.println("rating!!!"+curMovie.rating);
            rotateY(PI/2);
        } else {
            System.out.println("rating123431: "+curMovie.rating);
            rotateY(-PI/2);
        }

        pushMatrix();
        
        textSize(titleSize);   
        textAlign(LEFT, TOP);   
        text(curMovie.title, x, y, z);
        
        popMatrix();
    }

}
//void keyPressed() {
//  //use arrow keys to select increasing/decreasing years
//  if (keyCode == 38) {
//    startSelect--;
//    if (startSelect < 0) {
//      startSelect = YEAR_COUNT -1;
//    }
//  } 
//  if (keyCode == 40) {
//    startSelect++;
//    if (startSelect >= YEAR_COUNT) {
//      startSelect = 0;
//    } 
//  }
  
//  //use +/- to increase scale of selected year
//  //need to use log scale so its apparent
//  //println("key: ", keyCode);
//  if (keyCode == 61 && heightMult < 8) {
//    //plus
//    heightMult = heightMult * 1.5;
//  }
//  if (keyCode == 45) {
//    //minus
//    if (heightMult >= 1.5) {
//      heightMult = heightMult /1.5;
//    } else {
//      heightMult = 1.0;
//    }
//  }
//}
public void loadData() {
   table = loadTable("movie2023-2.csv", "header");
   numRows = table.getRowCount();
   
   for(int i=0; i<numRows; i++){
    int year = table.getInt(i,5);
    String title = table.getString(i,3);
    String genres = table.getString(i,7);

    int rating = table.getInt(i,8);
    int votes = table.getInt(i,9);

    ArrayList<Movie> list = map.getOrDefault(year, new ArrayList<>());

    list.add(new Movie(year, rating, votes, title, genres));
    
    map.put(year, new ArrayList<Movie>(list));
   }

    // for(int year: map.keySet()){
    //   ArrayList<Movie> list1 = map.get(year);
    //   List<PVector> listcur = new ArrayList<PVector>();
    //   for(Movie m : list1){
    //     float x = map(m.rating, 0, 10, -minRadius, minRadius);
    //     float y = map(m.votes, 5000, 590000, -minRadius, minRadius);
    //     float z = map(m.year, 2020, 2024, -minRadius, minRadius);
    //     listcur.add(new PVector(x, y ,z));
    //   }
    //   listAll.add(listcur);
    // }
}
   
  //  
   
  //  System.out.print(categories.size()+ " "+numRows);

  //  for (int i = 0; i < categories.size(); i++) {
  //    int year = int(categories.get(i).year);
  //    int month = int(categories.get(i).month);
  //    float percentage = categories.get(i).percentage;
  //    String category = categories.get(i).category;

  //    //System.out.println(year+" "+month+" "+percentage+" "+category);

  //    float theta = map(year, 2006, 2025, 0, 2*PI);
  //    float phi = map(month, 1, 13, 0, 2*PI);
  //    float r = map(percentage, 0, 0.25, minRadius, maxRadius);
  //    float x = r * sin(phi) * cos(theta);
  //    float y = r * sin(phi) * sin(theta);
  //    float z = r * cos(phi);

  //   // float x = r * cos(theta) * radiusMultiplier;
  //   // float y = map(month, 1, 12, -100, 100) * radiusMultiplier;
  //   // float z = map(percentage, 0, 0.2, -100, 100) * radiusMultiplier;

  //    //z = 

  //    points[i] = new PVector(x, y, z);
  //    // percentages[i] = percentage;
  //  }

//void drawLabels(){
//   fill(255);
//   textSize(30);
//   pushMatrix();
//   textAlign(LEFT, TOP);
//   translate(-50, 50, 50);
//   scale(0.1);
//   text("2006", 0, 0, 0);
//   popMatrix();
  
//   pushMatrix();
//   textAlign(RIGHT, TOP);
//   translate(50, 50, 50);
//   scale(0.1);
//   text("2023", 0, 0, 0);
//   popMatrix();
  
//   pushMatrix();
//   textAlign(RIGHT, TOP);
//   translate(-50, -50, 50);
//   scale(0.1);
//   text("Dec", 0, 0, 0);
//   popMatrix();
  
//   pushMatrix();
//   textAlign(RIGHT, BOTTOM);
//   translate(-50, 50, 50);
//   scale(0.1);
//   text("Jan", 0, 0, 0);
//   popMatrix();
  
//   pushMatrix();
//   textAlign(LEFT, CENTER);
//   translate(50, 50, 50);
//   scale(0.1);
//   text("Percentage", 0, 0, 0);
//   popMatrix();
  
//   pushMatrix();
//   textAlign(LEFT, CENTER);
//   translate(50, 50, -50);
//   scale(0.1);
//   text("Perta", 0, 0, 0);
//   popMatrix();
// }







  // for(int i=0; i<categories.size(); i++){
    // float yearAxis = map(categories.get(i).year, 2006, 2023, -50, 50);
    // // float monthAxis = categories.get(i)+0.000;
    // float monthAxis = map(categories.get(i).month, 1, 12, -50, 50);
    // float percentageAxis = map(categories.get(i).percentage, 0, 1.1, -50, 50);
    // color c = elementDetermine(categories.get(i).category);

    // We only draw the points that are later than 2005-12-31
    // if (yearAxis > map(2006, 2006, 2023, -50, 50)){
    //     pushMatrix();
    //     translate(yearAxis, monthAxis, percentageAxis);
    //     strokeWeight(2);
    //     stroke(c);
    //     point(0,0,0);
    //     // compute the mouse distance with the point
    //     float mouseObjectDistance = sq(mouseX-screenX(0,0,0)) + sq(mouseY-screenY(0,0,0));
    //     // if the distance is smaller than a certain value
    //     if(mouseObjectDistance < 1000){
    //     // add a bigger point
    //     strokeWeight(10);
    //     point(0,0,0);
    //     fill(255,255,255);
    //     // add text label
    //     textMode(SHAPE);
    //     // if the distance is close, make the textsize smaller
    //     if(cam.getDistance()<100){
    //     textSize(3);}
    //     // if the distance is far, make the textsize bigger
    //     else{
    //         textSize(5);}
    //     String ca = " "+categories.get(i).percentage+"%"+categories.get(i).date;
    //     text(categories.get(i).category+ca,0,0);
    //     }
    //     popMatrix();
    // }
  // }

  // float z1, z2, z3, z4, x1, x2, y1, y2;

//   cColor = color(chinaHue, chinaSaturation, chinaBright, chinaTrans);
//   fill(cColor);

//   for (int i = beginDewey; i < endDewey; i++) {
    
//       beginShape(QUADS);
//       z1 = min(categories.get(i).percentage, Z)+zBase;
//       z2 = min(cVolume[j+1][i], Z)+zBase;
//       z3 = min(cVolume[j+1][i+1], Z)+zBase;
//       z4 = min(cVolume[j][i+1], Z)+zBase;

//       x1 = (i-beginDewey)*adjustX;
//       x2 = (i+1-beginDewey)*adjustX;
//       y1 = j*adjustY;
//       y2 = (j+1)*adjustY;
//       vertex(x1, y1, z1);
//       vertex(x1, y2, z2);
//       vertex(x2, y2, z3);
//       vertex(x2, y1, z4);
//       endShape();
    
//   }
  
  // drawLabels();  
    
  // fill(200, 20);
  // noStroke();
  // box(100);


  public void settings() { size(1000, 800, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "project3_jingpeng" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
